
extern crate proc_macro;


use std::collections::HashMap;

use std::fs;
use tinybmp;
use tinybmp::ColorTable;
use embedded_graphics::pixelcolor::Rgb888;
use embedded_graphics::prelude::RgbColor;

pub static PALETTE: [(u8, u8, u8, u8); 256] = [
    (0x1a, 0x1a, 0x1a, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5d, 0xFF), (0x74, 0x74, 0x74, 0xFF), (0x8b, 0x8b, 0x8a, 0xFF), (0xa1, 0xa1, 0xa1, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x1a, 0x1e, 0x00, 0xFF), (0x31, 0x35, 0x0a, 0xFF), (0x47, 0x4b, 0x21, 0xFF), (0x5e, 0x61, 0x35, 0xFF), (0x75, 0x78, 0x4d, 0xFF), (0x8c, 0x8f, 0x65, 0xFF), (0xa2, 0xa5, 0x7c, 0xFF), (0xb9, 0xbd, 0x93, 0xFF),
    (0x1a, 0x22, 0x00, 0xFF), (0x31, 0x39, 0x00, 0xFF), (0x47, 0x4f, 0x00, 0xFF), (0x5d, 0x65, 0x0e, 0xFF), (0x72, 0x7b, 0x24, 0xFF), (0x8b, 0x93, 0x3d, 0xFF), (0xa2, 0xaa, 0x52, 0xFF), (0xb9, 0xc2, 0x69, 0xFF),
    (0x1a, 0x26, 0x00, 0xFF), (0x31, 0x3d, 0x00, 0xFF), (0x48, 0x54, 0x00, 0xFF), (0x5d, 0x6a, 0x00, 0xFF), (0x74, 0x80, 0x00, 0xFF), (0x8c, 0x98, 0x14, 0xFF), (0xa2, 0xae, 0x29, 0xFF), (0xb9, 0xc5, 0x41, 0xFF),

    (0x1b, 0x1b, 0x1b, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x48, 0x48, 0x48, 0xFF), (0x5e, 0x5e, 0x5e, 0xFF), (0x75, 0x75, 0x75, 0xFF), (0x8c, 0x8c, 0x8c, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x2c, 0x19, 0x00, 0xFF), (0x42, 0x2f, 0x15, 0xFF), (0x58, 0x46, 0x2d, 0xFF), (0x70, 0x5c, 0x41, 0xFF), (0x86, 0x72, 0x59, 0xFF), (0x9e, 0x89, 0x6f, 0xFF), (0xb4, 0x9f, 0x86, 0xFF), (0xcb, 0xb7, 0x9f, 0xFF),
    (0x3c, 0x16, 0x00, 0xFF), (0x53, 0x2d, 0x00, 0xFF), (0x69, 0x43, 0x0f, 0xFF), (0x80, 0x59, 0x24, 0xFF), (0x96, 0x70, 0x3b, 0xFF), (0xae, 0x87, 0x52, 0xFF), (0xc4, 0x9e, 0x68, 0xFF), (0xdc, 0xb5, 0x7f, 0xFF),
    (0x4c, 0x15, 0x00, 0xFF), (0x63, 0x2a, 0x00, 0xFF), (0x7b, 0x41, 0x00, 0xFF), (0x92, 0x59, 0x09, 0xFF), (0xa7, 0x6e, 0x1e, 0xFF), (0xbf, 0x86, 0x35, 0xFF), (0xd6, 0x9b, 0x4b, 0xFF), (0xed, 0xb2, 0x62, 0xFF),

    (0x1a, 0x1a, 0x1a, 0xFF), (0x32, 0x32, 0x32, 0xFF), (0x48, 0x48, 0x48, 0xFF), (0x5e, 0x5e, 0x5e, 0xFF), (0x74, 0x74, 0x73, 0xFF), (0x8b, 0x8b, 0x8b, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x32, 0x14, 0x1b, 0xFF), (0x48, 0x2a, 0x31, 0xFF), (0x5e, 0x40, 0x47, 0xFF), (0x76, 0x57, 0x5e, 0xFF), (0x8c, 0x6e, 0x74, 0xFF), (0xa3, 0x85, 0x8c, 0xFF), (0xb9, 0x9b, 0xa2, 0xFF), (0xd1, 0xb3, 0xba, 0xFF),
    (0x48, 0x0c, 0x19, 0xFF), (0x60, 0x23, 0x30, 0xFF), (0x77, 0x3a, 0x47, 0xFF), (0x8f, 0x50, 0x5e, 0xFF), (0xa3, 0x66, 0x74, 0xFF), (0xbb, 0x7d, 0x8b, 0xFF), (0xd2, 0x94, 0xa2, 0xFF), (0xea, 0xac, 0xb9, 0xFF),
    (0x61, 0x06, 0x1b, 0xFF), (0x78, 0x1d, 0x31, 0xFF), (0x8e, 0x33, 0x48, 0xFF), (0xa6, 0x4a, 0x5e, 0xFF), (0xbc, 0x5f, 0x74, 0xFF), (0xd3, 0x77, 0x8c, 0xFF), (0xea, 0x8c, 0xa2, 0xFF), (0xff, 0xa5, 0xba, 0xFF),

    (0x1a, 0x1a, 0x1a, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5d, 0xFF), (0x74, 0x74, 0x73, 0xFF), (0x8b, 0x8b, 0x8b, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x2b, 0x12, 0x35, 0xFF), (0x41, 0x29, 0x4d, 0xFF), (0x57, 0x40, 0x60, 0xFF), (0x6e, 0x55, 0x7c, 0xFF), (0x84, 0x6c, 0x91, 0xFF), (0x9b, 0x83, 0xa8, 0xFF), (0xb2, 0x99, 0xbe, 0xFF), (0xc8, 0xb0, 0xd6, 0xFF),
    (0x3d, 0x0b, 0x51, 0xFF), (0x55, 0x21, 0x69, 0xFF), (0x6a, 0x38, 0x7f, 0xFF), (0x82, 0x4e, 0x96, 0xFF), (0x99, 0x65, 0xac, 0xFF), (0xb0, 0x7c, 0xc3, 0xFF), (0xc7, 0x92, 0xdb, 0xFF), (0xdd, 0xa9, 0xf1, 0xFF),
    (0x4e, 0x04, 0x6d, 0xFF), (0x65, 0x1a, 0x83, 0xFF), (0x7c, 0x30, 0x9a, 0xFF), (0x93, 0x48, 0xb2, 0xFF), (0xa9, 0x5e, 0xc8, 0xFF), (0xc0, 0x74, 0xde, 0xFF), (0xd6, 0x8a, 0xf5, 0xFF), (0xed, 0xa2, 0xff, 0xFF),

    (0x1a, 0x1a, 0x1a, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5d, 0xFF), (0x74, 0x74, 0x74, 0xFF), (0x8c, 0x8c, 0x8c, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x1a, 0x16, 0x40, 0xFF), (0x31, 0x2d, 0x57, 0xFF), (0x48, 0x44, 0x6e, 0xFF), (0x5e, 0x5a, 0x84, 0xFF), (0x75, 0x71, 0x9b, 0xFF), (0x8c, 0x88, 0xb2, 0xFF), (0xa2, 0x9e, 0xc8, 0xFF), (0xb9, 0xb5, 0xdf, 0xFF),
    (0x1a, 0x12, 0x66, 0xFF), (0x31, 0x29, 0x7d, 0xFF), (0x48, 0x3f, 0x93, 0xFF), (0x5e, 0x56, 0xac, 0xFF), (0x74, 0x6c, 0xc1, 0xFF), (0x8c, 0x84, 0xda, 0xFF), (0xa2, 0x9a, 0xf0, 0xFF), (0xb9, 0xb1, 0xff, 0xFF),
    (0x1b, 0x0f, 0x8f, 0xFF), (0x32, 0x25, 0xa6, 0xFF), (0x48, 0x3c, 0xbe, 0xFF), (0x5f, 0x52, 0xd4, 0xFF), (0x74, 0x68, 0xeb, 0xFF), (0x8c, 0x80, 0xff, 0xFF), (0xa2, 0x96, 0xff, 0xFF), (0xb9, 0xad, 0xff, 0xFF),

    (0x1a, 0x1a, 0x1a, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5d, 0xFF), (0x74, 0x74, 0x74, 0xFF), (0x8b, 0x8b, 0x8b, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb8, 0xb8, 0xb8, 0xFF),
    (0x08, 0x1c, 0x33, 0xFF), (0x1f, 0x33, 0x4a, 0xFF), (0x36, 0x4a, 0x60, 0xFF), (0x4c, 0x60, 0x78, 0xFF), (0x62, 0x77, 0x8e, 0xFF), (0x7a, 0x8d, 0xa5, 0xFF), (0x90, 0xa4, 0xbb, 0xFF), (0xa7, 0xbc, 0xd2, 0xFF),
    (0x00, 0x1d, 0x50, 0xFF), (0x10, 0x34, 0x67, 0xFF), (0x27, 0x4b, 0x7e, 0xFF), (0x3b, 0x62, 0x94, 0xFF), (0x52, 0x78, 0xaa, 0xFF), (0x6a, 0x90, 0xc2, 0xFF), (0x80, 0xa6, 0xd9, 0xFF), (0x96, 0xbd, 0xf0, 0xFF),
    (0x00, 0x21, 0x6d, 0xFF), (0x00, 0x37, 0x82, 0xFF), (0x15, 0x4e, 0x9a, 0xFF), (0x2c, 0x64, 0xb0, 0xFF), (0x41, 0x7a, 0xc6, 0xFF), (0x5a, 0x92, 0xde, 0xFF), (0x70, 0xa8, 0xf4, 0xFF), (0x87, 0xc0, 0xff, 0xFF),

    (0x1a, 0x1a, 0x1a, 0xFF), (0x31, 0x31, 0x31, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5d, 0xFF), (0x73, 0x73, 0x73, 0xFF), (0x8b, 0x8b, 0x8b, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb8, 0xb9, 0xb9, 0xFF),
    (0x04, 0x20, 0x17, 0xFF), (0x1a, 0x36, 0x2f, 0xFF), (0x31, 0x4d, 0x47, 0xFF), (0x46, 0x64, 0x5d, 0xFF), (0x5e, 0x7a, 0x74, 0xFF), (0x75, 0x92, 0x8c, 0xFF), (0x8a, 0xa8, 0x9f, 0xFF), (0xa1, 0xbf, 0xb6, 0xFF),
    (0x00, 0x27, 0x19, 0xFF), (0x03, 0x3d, 0x31, 0xFF), (0x1a, 0x54, 0x47, 0xFF), (0x2f, 0x6b, 0x5d, 0xFF), (0x46, 0x81, 0x73, 0xFF), (0x5d, 0x99, 0x8b, 0xFF), (0x73, 0xaf, 0xa2, 0xFF), (0x89, 0xc6, 0xb8, 0xFF),
    (0x00, 0x2f, 0x1a, 0xFF), (0x00, 0x45, 0x31, 0xFF), (0x01, 0x5c, 0x47, 0xFF), (0x17, 0x72, 0x5d, 0xFF), (0x2d, 0x88, 0x73, 0xFF), (0x45, 0xa0, 0x8b, 0xFF), (0x5c, 0xb6, 0xa2, 0xFF), (0x72, 0xcd, 0xb8, 0xFF),

    (0x1a, 0x1a, 0x19, 0xFF), (0x30, 0x30, 0x30, 0xFF), (0x47, 0x47, 0x47, 0xFF), (0x5d, 0x5d, 0x5e, 0xFF), (0x74, 0x74, 0x74, 0xFF), (0x8b, 0x8b, 0x8b, 0xFF), (0xa2, 0xa2, 0xa2, 0xFF), (0xb9, 0xb9, 0xb9, 0xFF),
    (0x0a, 0x22, 0x00, 0xFF), (0x21, 0x38, 0x13, 0xFF), (0x37, 0x4f, 0x2b, 0xFF), (0x4c, 0x65, 0x40, 0xFF), (0x63, 0x7b, 0x57, 0xFF), (0x7a, 0x93, 0x6d, 0xFF), (0x91, 0xa9, 0x82, 0xFF), (0xa8, 0xc0, 0x99, 0xFF),
    (0x00, 0x28, 0x00, 0xFF), (0x0f, 0x3e, 0x00, 0xFF), (0x27, 0x56, 0x12, 0xFF), (0x3b, 0x6d, 0x26, 0xFF), (0x53, 0x83, 0x3d, 0xFF), (0x6a, 0x9a, 0x56, 0xFF), (0x80, 0xb1, 0x6b, 0xFF), (0x97, 0xc7, 0x82, 0xFF),
    (0x00, 0x30, 0x00, 0xFF), (0x00, 0x47, 0x00, 0xFF), (0x15, 0x5e, 0x00, 0xFF), (0x2c, 0x75, 0x0b, 0xFF), (0x41, 0x8a, 0x21, 0xFF), (0x58, 0xa2, 0x39, 0xFF), (0x70, 0xb9, 0x4f, 0xFF), (0x85, 0xd0, 0x66, 0xFF),
];


fn palette_as_rgb888() -> Vec<Rgb888> {
    let mut palette = vec![];

    for color in PALETTE.iter() {
        palette.push(Rgb888::new(color.0, color.1, color.2))
    }

    palette
}

fn color_map() -> HashMap<Rgb888, u8> {
    let mut map = HashMap::new();

    let palette = palette_as_rgb888();

    for (i, color) in palette.iter().enumerate() {
        let h: u8 = (i / 32) as u8;
        let s: u8 = ((i % 32) / 8) as u8;
        let l: u8 = (i % 8) as u8;
        map.insert(color.clone(), (h << 5) | (s<< 3) | l);
    }

    map
}



fn derive_gametank_colors(color_table: &ColorTable) -> Vec<u8>{
    let mut colors = vec![];
    let color_map = color_map();

    for i in 0..color_table.len() {
        let color = color_table.get(i as u32).unwrap();
        // TODO: warn with closest color match instead of panicking
        colors.push(*color_map.get(&color).expect(&format!("{:?} does not exist in gametank color palette", color)));
    }

    colors.dedup();

    colors
}

fn pack_indices(indices: Vec<u8>, pixels_per_byte: u8) -> Vec<u8> {
    let bits_per_index = 8 / pixels_per_byte; // division here

    // chunk by pixels per byte
    // map each chunk to a single u8 by folding into an accumulator

    indices
        .chunks(pixels_per_byte as usize)
        .map(|chunk| {
            chunk.iter().enumerate().fold(0u8, |acc, (i, &val)| {
                acc | (val << (bits_per_index * i as u8))
            })
        })
        .collect()
}

pub struct SpriteSheetImage {
    pub(crate) pixels_per_byte: u8,
    pub(crate) width: u8,
    pub(crate) height: u8,
    pub(crate) palette: Vec<u8>,
    pub(crate) pixel_array: Vec<u8>,
}

impl SpriteSheetImage {
    pub fn load_spritesheet(file_path: String) -> SpriteSheetImage {
        // Read the file
        let file_contents = fs::read(file_path).expect("Failed to read file");

        let bmp = tinybmp::Bmp::<Rgb888>::from_slice(file_contents.as_slice()).unwrap();
        let color_map = color_map();
        let color_palette = derive_gametank_colors(bmp.as_raw().color_table().unwrap());

        let num_colors = color_palette.len();

        let bits_per_color = match num_colors {
            0..=2 => 1,  // Up to 2 colors can be represented with 1 bit each
            3..=4 => 2,  // Up to 4 colors need 2 bits each
            5..=16 => 4, // Up to 16 colors need 4 bits each
            _ => 8       // More than 16 colors will use 8 bits (1 byte) per color
        };

        let pixels_per_byte: u8 = 8 / bits_per_color;

        // map bmp pixels to indices
        let pixel_indices: Vec<u8> = bmp.pixels()
            .map(|pixel| {
                let gt_color = color_map.get(&pixel.1).unwrap();
                let idx = color_palette.iter().position(|c| c == gt_color).unwrap();
                idx as u8
            }).collect();

        let packed_pixels = pack_indices(pixel_indices, pixels_per_byte);

        let header = bmp.as_raw().header();

        let width = header.image_size.width as u8;
        let height = header.image_size.height as u8;
        let _pixel_array_size = packed_pixels.len();
        
        SpriteSheetImage {
            pixels_per_byte,
            width,
            height,
            palette: color_palette,
            pixel_array: packed_pixels,
        }
    }
}

/// Expands packed pixel data back to one byte per pixel, returning the actual palette color values
pub fn expand_pixels(image: &SpriteSheetImage) -> Vec<u8> {
    let bits_per_pixel = 8 / image.pixels_per_byte;
    let mask = (1u8 << bits_per_pixel) - 1;
    
    let total_pixels = (image.width as usize) * (image.height as usize);
    let mut result = Vec::with_capacity(total_pixels);
    
    for byte in &image.pixel_array {
        for i in 0..image.pixels_per_byte {
            if result.len() >= total_pixels {
                break;
            }
            let index = (byte >> (bits_per_pixel * i)) & mask;
            let color = image.palette[index as usize];
            result.push(color);
        }
    }
    
    result
}

/// Load a BMP file and return raw pixel data mapped to GameTank colors.
/// Works with both indexed and true-color BMP files.
/// Colors not in the palette are mapped to the closest match.
pub fn load_bmp_raw(file_path: String) -> Vec<u8> {
    let file_contents = fs::read(&file_path).expect(&format!("Failed to read file: {}", file_path));
    let bmp = tinybmp::Bmp::<Rgb888>::from_slice(file_contents.as_slice())
        .expect(&format!("Failed to parse BMP: {}", file_path));
    let color_map = color_map();
    let palette = palette_as_rgb888();

    // Map each pixel directly to GameTank colors
    bmp.pixels()
        .map(|pixel| {
            let color = pixel.1;
            // Try exact match first
            if let Some(&gt_color) = color_map.get(&color) {
                gt_color
            } else {
                // Find closest color in palette
                find_closest_color(&color, &palette, &color_map)
            }
        })
        .collect()
}

/// Find the closest color in the GameTank palette using Euclidean distance in RGB space
fn find_closest_color(target: &Rgb888, palette: &[Rgb888], color_map: &HashMap<Rgb888, u8>) -> u8 {
    let mut best_match = palette[0];
    let mut best_distance = color_distance(target, &palette[0]);

    for color in palette.iter().skip(1) {
        let distance = color_distance(target, color);
        if distance < best_distance {
            best_distance = distance;
            best_match = *color;
        }
    }

    *color_map.get(&best_match).unwrap()
}

/// Calculate squared Euclidean distance between two colors
fn color_distance(c1: &Rgb888, c2: &Rgb888) -> u32 {
    let dr = (c1.r() as i32) - (c2.r() as i32);
    let dg = (c1.g() as i32) - (c2.g() as i32);
    let db = (c1.b() as i32) - (c2.b() as i32);
    (dr * dr + dg * dg + db * db) as u32
}
