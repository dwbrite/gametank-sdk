
extern crate proc_macro;


use std::collections::HashMap;

use std::fs;
use tinybmp;
use tinybmp::ColorTable;
use embedded_graphics::pixelcolor::Rgb888;
use embedded_graphics::prelude::RgbColor;

/// Color used as a transparent flag
pub static TRANSPARENT_COLOR: (u8, u8, u8) = (0xff, 0x00, 0xff);

/// Palette of colors based on the emulator's capture-based palette
pub static PALETTE: [(u8, u8, u8); 256] = [
    (0x1a, 0x1a, 0x1a), (0x31, 0x31, 0x31), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5d), (0x74, 0x74, 0x74), (0x8b, 0x8b, 0x8a), (0xa1, 0xa1, 0xa1), (0xb9, 0xb9, 0xb9),
    (0x1a, 0x1e, 0x00), (0x31, 0x35, 0x0a), (0x47, 0x4b, 0x21), (0x5e, 0x61, 0x35), (0x75, 0x78, 0x4d), (0x8c, 0x8f, 0x65), (0xa2, 0xa5, 0x7c), (0xb9, 0xbd, 0x93),
    (0x1a, 0x22, 0x00), (0x31, 0x39, 0x00), (0x47, 0x4f, 0x00), (0x5d, 0x65, 0x0e), (0x72, 0x7b, 0x24), (0x8b, 0x93, 0x3d), (0xa2, 0xaa, 0x52), (0xb9, 0xc2, 0x69),
    (0x1a, 0x26, 0x00), (0x31, 0x3d, 0x00), (0x48, 0x54, 0x00), (0x5d, 0x6a, 0x00), (0x74, 0x80, 0x00), (0x8c, 0x98, 0x14), (0xa2, 0xae, 0x29), (0xb9, 0xc5, 0x41),
    (0x1b, 0x1b, 0x1b), (0x31, 0x31, 0x31), (0x48, 0x48, 0x48), (0x5e, 0x5e, 0x5e), (0x75, 0x75, 0x75), (0x8c, 0x8c, 0x8c), (0xa2, 0xa2, 0xa2), (0xb9, 0xb9, 0xb9),
    (0x2c, 0x19, 0x00), (0x42, 0x2f, 0x15), (0x58, 0x46, 0x2d), (0x70, 0x5c, 0x41), (0x86, 0x72, 0x59), (0x9e, 0x89, 0x6f), (0xb4, 0x9f, 0x86), (0xcb, 0xb7, 0x9f),
    (0x3c, 0x16, 0x00), (0x53, 0x2d, 0x00), (0x69, 0x43, 0x0f), (0x80, 0x59, 0x24), (0x96, 0x70, 0x3b), (0xae, 0x87, 0x52), (0xc4, 0x9e, 0x68), (0xdc, 0xb5, 0x7f),
    (0x4c, 0x15, 0x00), (0x63, 0x2a, 0x00), (0x7b, 0x41, 0x00), (0x92, 0x59, 0x09), (0xa7, 0x6e, 0x1e), (0xbf, 0x86, 0x35), (0xd6, 0x9b, 0x4b), (0xed, 0xb2, 0x62),
    (0x1a, 0x1a, 0x1a), (0x32, 0x32, 0x32), (0x48, 0x48, 0x48), (0x5e, 0x5e, 0x5e), (0x74, 0x74, 0x73), (0x8b, 0x8b, 0x8b), (0xa2, 0xa2, 0xa2), (0xb9, 0xb9, 0xb9),
    (0x32, 0x14, 0x1b), (0x48, 0x2a, 0x31), (0x5e, 0x40, 0x47), (0x76, 0x57, 0x5e), (0x8c, 0x6e, 0x74), (0xa3, 0x85, 0x8c), (0xb9, 0x9b, 0xa2), (0xd1, 0xb3, 0xba),
    (0x48, 0x0c, 0x19), (0x60, 0x23, 0x30), (0x77, 0x3a, 0x47), (0x8f, 0x50, 0x5e), (0xa3, 0x66, 0x74), (0xbb, 0x7d, 0x8b), (0xd2, 0x94, 0xa2), (0xea, 0xac, 0xb9),
    (0x61, 0x06, 0x1b), (0x78, 0x1d, 0x31), (0x8e, 0x33, 0x48), (0xa6, 0x4a, 0x5e), (0xbc, 0x5f, 0x74), (0xd3, 0x77, 0x8c), (0xea, 0x8c, 0xa2), (0xff, 0xa5, 0xba),
    (0x1a, 0x1a, 0x1a), (0x31, 0x31, 0x31), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5d), (0x74, 0x74, 0x73), (0x8b, 0x8b, 0x8b), (0xa2, 0xa2, 0xa2), (0xb9, 0xb9, 0xb9),
    (0x2b, 0x12, 0x35), (0x41, 0x29, 0x4d), (0x57, 0x40, 0x60), (0x6e, 0x55, 0x7c), (0x84, 0x6c, 0x91), (0x9b, 0x83, 0xa8), (0xb2, 0x99, 0xbe), (0xc8, 0xb0, 0xd6),
    (0x3d, 0x0b, 0x51), (0x55, 0x21, 0x69), (0x6a, 0x38, 0x7f), (0x82, 0x4e, 0x96), (0x99, 0x65, 0xac), (0xb0, 0x7c, 0xc3), (0xc7, 0x92, 0xdb), (0xdd, 0xa9, 0xf1),
    (0x4e, 0x04, 0x6d), (0x65, 0x1a, 0x83), (0x7c, 0x30, 0x9a), (0x93, 0x48, 0xb2), (0xa9, 0x5e, 0xc8), (0xc0, 0x74, 0xde), (0xd6, 0x8a, 0xf5), (0xed, 0xa2, 0xff),
    (0x1a, 0x1a, 0x1a), (0x31, 0x31, 0x31), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5d), (0x74, 0x74, 0x74), (0x8c, 0x8c, 0x8c), (0xa2, 0xa2, 0xa2), (0xb9, 0xb9, 0xb9),
    (0x1a, 0x16, 0x40), (0x31, 0x2d, 0x57), (0x48, 0x44, 0x6e), (0x5e, 0x5a, 0x84), (0x75, 0x71, 0x9b), (0x8c, 0x88, 0xb2), (0xa2, 0x9e, 0xc8), (0xb9, 0xb5, 0xdf),
    (0x1a, 0x12, 0x66), (0x31, 0x29, 0x7d), (0x48, 0x3f, 0x93), (0x5e, 0x56, 0xac), (0x74, 0x6c, 0xc1), (0x8c, 0x84, 0xda), (0xa2, 0x9a, 0xf0), (0xb9, 0xb1, 0xff),
    (0x1b, 0x0f, 0x8f), (0x32, 0x25, 0xa6), (0x48, 0x3c, 0xbe), (0x5f, 0x52, 0xd4), (0x74, 0x68, 0xeb), (0x8c, 0x80, 0xff), (0xa2, 0x96, 0xff), (0xb9, 0xad, 0xff),
    (0x1a, 0x1a, 0x1a), (0x31, 0x31, 0x31), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5d), (0x74, 0x74, 0x74), (0x8b, 0x8b, 0x8b), (0xa2, 0xa2, 0xa2), (0xb8, 0xb8, 0xb8),
    (0x08, 0x1c, 0x33), (0x1f, 0x33, 0x4a), (0x36, 0x4a, 0x60), (0x4c, 0x60, 0x78), (0x62, 0x77, 0x8e), (0x7a, 0x8d, 0xa5), (0x90, 0xa4, 0xbb), (0xa7, 0xbc, 0xd2),
    (0x00, 0x1d, 0x50), (0x10, 0x34, 0x67), (0x27, 0x4b, 0x7e), (0x3b, 0x62, 0x94), (0x52, 0x78, 0xaa), (0x6a, 0x90, 0xc2), (0x80, 0xa6, 0xd9), (0x96, 0xbd, 0xf0),
    (0x00, 0x21, 0x6d), (0x00, 0x37, 0x82), (0x15, 0x4e, 0x9a), (0x2c, 0x64, 0xb0), (0x41, 0x7a, 0xc6), (0x5a, 0x92, 0xde), (0x70, 0xa8, 0xf4), (0x87, 0xc0, 0xff),
    (0x1a, 0x1a, 0x1a), (0x31, 0x31, 0x31), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5d), (0x73, 0x73, 0x73), (0x8b, 0x8b, 0x8b), (0xa2, 0xa2, 0xa2), (0xb8, 0xb9, 0xb9),
    (0x04, 0x20, 0x17), (0x1a, 0x36, 0x2f), (0x31, 0x4d, 0x47), (0x46, 0x64, 0x5d), (0x5e, 0x7a, 0x74), (0x75, 0x92, 0x8c), (0x8a, 0xa8, 0x9f), (0xa1, 0xbf, 0xb6),
    (0x00, 0x27, 0x19), (0x03, 0x3d, 0x31), (0x1a, 0x54, 0x47), (0x2f, 0x6b, 0x5d), (0x46, 0x81, 0x73), (0x5d, 0x99, 0x8b), (0x73, 0xaf, 0xa2), (0x89, 0xc6, 0xb8),
    (0x00, 0x2f, 0x1a), (0x00, 0x45, 0x31), (0x01, 0x5c, 0x47), (0x17, 0x72, 0x5d), (0x2d, 0x88, 0x73), (0x45, 0xa0, 0x8b), (0x5c, 0xb6, 0xa2), (0x72, 0xcd, 0xb8),
    (0x1a, 0x1a, 0x19), (0x30, 0x30, 0x30), (0x47, 0x47, 0x47), (0x5d, 0x5d, 0x5e), (0x74, 0x74, 0x74), (0x8b, 0x8b, 0x8b), (0xa2, 0xa2, 0xa2), (0xb9, 0xb9, 0xb9),
    (0x0a, 0x22, 0x00), (0x21, 0x38, 0x13), (0x37, 0x4f, 0x2b), (0x4c, 0x65, 0x40), (0x63, 0x7b, 0x57), (0x7a, 0x93, 0x6d), (0x91, 0xa9, 0x82), (0xa8, 0xc0, 0x99),
    (0x00, 0x28, 0x00), (0x0f, 0x3e, 0x00), (0x27, 0x56, 0x12), (0x3b, 0x6d, 0x26), (0x53, 0x83, 0x3d), (0x6a, 0x9a, 0x56), (0x80, 0xb1, 0x6b), (0x97, 0xc7, 0x82),
    (0x00, 0x30, 0x00), (0x00, 0x47, 0x00), (0x15, 0x5e, 0x00), (0x2c, 0x75, 0x0b), (0x41, 0x8a, 0x21), (0x58, 0xa2, 0x39), (0x70, 0xb9, 0x4f), (0x85, 0xd0, 0x66),
];

/// Converts the palette from RGB u8 values to RGB888
fn palette_as_rgb888() -> Vec<Rgb888> {
    let mut palette = vec![];

    for color in PALETTE.iter() {
        palette.push(Rgb888::new(color.0, color.1, color.2))
    }

    palette
}

/// Converts the transparent flag color from RGB u8 values to RGB888
fn transparent_as_rgb888() -> Rgb888 {
    return Rgb888::new(TRANSPARENT_COLOR.0, TRANSPARENT_COLOR.1, TRANSPARENT_COLOR.2);
}

/// Returns a hash map converting RGB888 values to HSL u8 values that can be read to the GameTank blitter
fn color_map() -> HashMap<Rgb888, u8> {
    let mut map = HashMap::new();
    let palette = palette_as_rgb888();

    for (i, color) in palette.iter().enumerate() {
        let h: u8 = (i / 32) as u8;
        let s: u8 = ((i % 32) / 8) as u8;
        let l: u8 = (i % 8) as u8;
        map.insert(color.clone(), (h << 5) | (s<< 3) | l);
    }

    map
}

/// Converts the colors contained in a BMP color table to GameTank compatible HSL u8 values
fn derive_gametank_color_table(color_table: &ColorTable) -> Vec<u8>{
    let mut colors = vec![];
    let color_map = color_map();
    let palette = palette_as_rgb888();
    let transparent = transparent_as_rgb888();

    for i in 0..color_table.len() {
        let color = color_table.get(i as u32).unwrap();

        let (value, exact) = color_to_gt_value(&color, &palette, &color_map, &transparent);

        if !exact {
            //warn here
        }
        
        colors.push(value);
    }

    colors.dedup();

    colors
}

fn pack_indices(indices: Vec<u8>, pixels_per_byte: u8) -> Vec<u8> {
    let bits_per_index = 8 / pixels_per_byte; // division here

    // chunk by pixels per byte
    // map each chunk to a single u8 by folding into an accumulator

    indices
        .chunks(pixels_per_byte as usize)
        .map(|chunk| {
            chunk.iter().enumerate().fold(0u8, |acc, (i, &val)| {
                acc | (val << (bits_per_index * i as u8))
            })
        })
        .collect()
}

pub struct SpriteSheetImage {
    pub(crate) pixels_per_byte: u8,
    pub(crate) width: u8,
    pub(crate) height: u8,
    pub(crate) palette: Vec<u8>,
    pub(crate) pixel_array: Vec<u8>,
}

impl SpriteSheetImage {
    pub fn load_spritesheet(file_path: String) -> SpriteSheetImage {
        // Read the file
        let file_contents = fs::read(file_path).expect("Failed to read file");

        let bmp = tinybmp::Bmp::<Rgb888>::from_slice(file_contents.as_slice()).unwrap();
        let color_map = color_map();
        let color_palette = derive_gametank_color_table(bmp.as_raw().color_table().unwrap());

        let num_colors = color_palette.len();

        let bits_per_color = match num_colors {
            0..=2 => 1,  // Up to 2 colors can be represented with 1 bit each
            3..=4 => 2,  // Up to 4 colors need 2 bits each
            5..=16 => 4, // Up to 16 colors need 4 bits each
            _ => 8       // More than 16 colors will use 8 bits (1 byte) per color
        };

        let pixels_per_byte: u8 = 8 / bits_per_color;

        // map bmp pixels to indices
        let pixel_indices: Vec<u8> = bmp.pixels()
            .map(|pixel| {
                let gt_color = color_map.get(&pixel.1).unwrap();
                let idx = color_palette.iter().position(|c| c == gt_color).unwrap();
                idx as u8
            }).collect();

        let packed_pixels = pack_indices(pixel_indices, pixels_per_byte);

        let header = bmp.as_raw().header();

        let width = header.image_size.width as u8;
        let height = header.image_size.height as u8;
        let _pixel_array_size = packed_pixels.len();
        
        SpriteSheetImage {
            pixels_per_byte,
            width,
            height,
            palette: color_palette,
            pixel_array: packed_pixels,
        }
    }
}

/// Load a BMP file and return raw pixel data mapped to GameTank colors.
/// Works with both indexed and true-color BMP files.
/// Colors not in the palette are mapped to the closest match.
pub fn load_bmp_raw(file_path: String) -> Vec<u8> {
    let file_contents = fs::read(&file_path).expect(&format!("Failed to read file: {}", file_path));
    let bmp = tinybmp::Bmp::<Rgb888>::from_slice(file_contents.as_slice())
        .expect(&format!("Failed to parse BMP: {}", file_path));
    let color_map = color_map();
    let palette = palette_as_rgb888();
    let transparent = transparent_as_rgb888();

    // Map each pixel directly to GameTank colors
    bmp.pixels()
        .map(|pixel| {
            let color = pixel.1;
            
            color_to_gt_value(&color, &palette, &color_map, &transparent).0
        })
        .collect()
}


// Unified method to convert a RGB888 values to GameTank HSL u8 ints with transparency and closest color support.
// Returns the closest HSL value and an "exact" flag if the lookup was an exact match in the palette
pub fn color_to_gt_value(target: &Rgb888, palette: &[Rgb888], color_map: &HashMap<Rgb888, u8>, transparent: &Rgb888) -> (u8, bool) {
    // Check if color matches transparent flag
    if target == transparent {
        (0x00, true)

    // Try exact match first
    } else if let Some(gt_color) = color_map.get(target) {
        (*gt_color, true)

    // Find closest color in palette
    } else {
        (find_closest_color(target, palette, color_map), false)
    }
}

/// Find the closest color in the GameTank palette using Euclidean distance in RGB space
fn find_closest_color(target: &Rgb888, palette: &[Rgb888], color_map: &HashMap<Rgb888, u8>) -> u8 {
    let mut best_match = palette[0];
    let mut best_distance = color_distance(target, &palette[0]);

    for color in palette.iter().skip(1) {
        let distance = color_distance(target, color);
        if distance < best_distance {
            best_distance = distance;
            best_match = *color;
        }
    }

    *color_map.get(&best_match).unwrap()
}

/// Calculate squared Euclidean distance between two colors
fn color_distance(c1: &Rgb888, c2: &Rgb888) -> u32 {
    let dr = (c1.r() as i32) - (c2.r() as i32);
    let dg = (c1.g() as i32) - (c2.g() as i32);
    let db = (c1.b() as i32) - (c2.b() as i32);
    (dr * dr + dg * dg + db * db) as u32
}
